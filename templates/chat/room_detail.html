{% extends "base.html" %}

{% block title %}Chat with {{ other_participant.name }} - StudyIt{% endblock %}

{% block extra_css %}
<style>
    .chat-container {
        display: flex;
        flex-direction: column;
        height: calc(100vh - 300px);
        max-height: 700px;
        background: white;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        overflow: hidden;
    }

    .chat-header {
        background: #003057;
        color: white;
        padding: 1rem 1.5rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 1.5rem;
        background: #f8f9fa;
    }

    .message {
        margin-bottom: 1rem;
        display: flex;
        flex-direction: column;
    }

    .message.own {
        align-items: flex-end;
    }

    .message.other {
        align-items: flex-start;
    }

    .message-bubble {
        max-width: 70%;
        padding: 0.75rem 1rem;
        border-radius: 18px;
        word-wrap: break-word;
    }

    .message.own .message-bubble {
        background: #003057;
        color: white;
    }

    .message.other .message-bubble {
        background: white;
        color: #333;
        border: 1px solid #ddd;
    }

    .message-time {
        font-size: 0.75rem;
        color: #999;
        margin-top: 0.25rem;
        padding: 0 0.5rem;
    }

    .chat-input-container {
        border-top: 1px solid #ddd;
        padding: 1rem 1.5rem;
        background: white;
    }

    .chat-input-form {
        display: flex;
        gap: 0.75rem;
    }

    .chat-input {
        flex: 1;
        padding: 0.75rem;
        border: 1px solid #ddd;
        border-radius: 20px;
        font-size: 1rem;
        resize: none;
    }

    .chat-input:focus {
        outline: none;
        border-color: #003057;
        box-shadow: 0 0 0 3px rgba(0, 48, 87, 0.1);
    }

    .send-button {
        background: #003057;
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        border-radius: 20px;
        font-weight: 500;
        cursor: pointer;
        white-space: nowrap;
    }

    .send-button:hover {
        background: #004080;
    }

    .send-button:disabled {
        background: #ccc;
        cursor: not-allowed;
    }

    /* Call UI Styles */
    .call-buttons {
        display: flex;
        gap: 0.5rem;
    }

    .call-btn {
        background: white;
        border: 2px solid #003057;
        color: #003057;
        padding: 0.5rem 1rem;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 500;
        font-size: 0.875rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        transition: all 0.2s;
    }

    .call-btn:hover {
        background: #003057;
        color: white;
    }

    .call-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    @keyframes pulse {

        0%,
        100% {
            transform: scale(1);
            box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7);
        }

        50% {
            transform: scale(1.05);
            box-shadow: 0 0 0 10px rgba(40, 167, 69, 0);
        }
    }

    /* Incoming Call Modal */
    .call-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 10000;
        justify-content: center;
        align-items: center;
    }

    .call-modal.active {
        display: flex;
    }

    .call-modal-content {
        background: white;
        padding: 2rem;
        border-radius: 20px;
        text-align: center;
        max-width: 400px;
        animation: slideUp 0.3s ease-out;
    }

    @keyframes slideUp {
        from {
            transform: translateY(50px);
            opacity: 0;
        }

        to {
            transform: translateY(0);
            opacity: 1;
        }
    }

    @keyframes slideDown {
        from {
            transform: translateY(-20px);
            opacity: 0;
        }

        to {
            transform: translateY(0);
            opacity: 1;
        }
    }

    .call-modal-avatar {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        background: #003057;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        margin: 0 auto 1rem;
    }

    .call-modal-actions {
        display: flex;
        gap: 1rem;
        justify-content: center;
        margin-top: 2rem;
    }

    .call-accept-btn,
    .call-reject-btn {
        padding: 1rem 2rem;
        border: none;
        border-radius: 50px;
        font-weight: 600;
        cursor: pointer;
        font-size: 1rem;
        transition: transform 0.2s;
    }

    .call-accept-btn {
        background: #28a745;
        color: white;
    }

    .call-accept-btn:hover {
        background: #218838;
        transform: scale(1.05);
    }

    .call-reject-btn {
        background: #dc3545;
        color: white;
    }

    .call-reject-btn:hover {
        background: #c82333;
        transform: scale(1.05);
    }

    /* Active Call Interface */
    .call-interface {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #1a1a1a;
        z-index: 9999;
        flex-direction: column;
    }

    .call-interface.active {
        display: flex;
    }

    .call-interface.minimized {
        display: block;
        width: 320px;
        height: 240px;
        top: auto;
        bottom: 20px;
        right: 20px;
        left: auto;
        border-radius: 15px;
        overflow: hidden;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        cursor: move;
        transition: none;
    }

    .call-interface.minimized .call-video-container {
        height: calc(100% - 60px);
    }

    .call-interface.minimized .remote-video {
        border-radius: 15px 15px 0 0;
    }

    .call-interface.minimized .local-video {
        width: 80px;
        height: 60px;
        bottom: 65px;
        right: 10px;
    }

    .call-interface.minimized .call-info {
        top: 10px;
        font-size: 0.75rem;
        padding: 0.5rem 1rem;
    }

    .call-interface.minimized .call-controls {
        padding: 0.5rem;
        gap: 0.5rem;
    }

    .call-interface.minimized .call-control-btn {
        width: 40px;
        height: 40px;
        font-size: 1rem;
    }

    .minimize-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 40px;
        height: 40px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.25rem;
        z-index: 10001;
        transition: all 0.2s;
    }

    .minimize-btn:hover {
        background: rgba(0, 0, 0, 0.9);
        transform: scale(1.1);
    }

    .maximize-btn {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 40px;
        height: 40px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.25rem;
        z-index: 10001;
        display: none;
        transition: all 0.2s;
    }

    .call-interface.minimized .maximize-btn {
        display: block;
    }

    .call-interface.minimized .minimize-btn {
        display: none;
    }

    .maximize-btn:hover {
        background: rgba(0, 0, 0, 0.9);
        transform: scale(1.1);
    }

    .call-video-container {
        flex: 1;
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .remote-video {
        width: 100%;
        height: 100%;
        object-fit: contain;
        background: #000;
    }

    .local-video {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 200px;
        height: 150px;
        object-fit: cover;
        border-radius: 10px;
        border: 3px solid white;
        background: #000;
    }

    .call-controls {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.9);
        padding: 1.5rem;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 1rem;
        z-index: 100;
    }

    .call-control-btn {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        border: none;
        cursor: pointer;
        font-size: 1.5rem;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .call-control-btn:hover {
        transform: scale(1.1);
    }

    .mute-btn {
        background: #4a5568;
        color: white;
    }

    .mute-btn.muted {
        background: #dc3545;
    }

    .video-btn {
        background: #4a5568;
        color: white;
    }

    .video-btn.disabled {
        background: #dc3545;
    }

    .end-call-btn {
        background: #dc3545;
        color: white;
    }

    .end-call-btn:hover {
        background: #c82333;
    }

    .call-info {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
        color: white;
        z-index: 10;
        background: rgba(0, 0, 0, 0.7);
        padding: 1rem 2rem;
        border-radius: 15px;
        backdrop-filter: blur(10px);
    }

    .call-status {
        font-size: 1rem;
        margin-bottom: 0.5rem;
        font-weight: 500;
    }

    .call-duration {
        font-size: 2rem;
        font-weight: bold;
        letter-spacing: 2px;
    }

    .call-interface.minimized .call-info {
        position: static;
        transform: none;
        background: rgba(0, 0, 0, 0.9);
        padding: 0.5rem 1rem;
        border-radius: 0;
    }

    .call-interface.minimized .call-status {
        font-size: 0.75rem;
        margin-bottom: 0.25rem;
    }

    .call-interface.minimized .call-duration {
        font-size: 1.25rem;
        letter-spacing: 1px;
    }
</style>
{% endblock %}

{% block content %}
<div style="max-width: 1000px; margin: 2rem auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <a href="{% url 'chat:room_list' %}" style="color: #003057; text-decoration: none; font-weight: 500;">‚Üê Back to
            Chats</a>
        <a href="{% url 'accounts:profile_detail' other_participant.user.id %}"
            style="color: #003057; text-decoration: none; font-weight: 500;">
            View Profile
        </a>
    </div>

    <div class="chat-container">
        <!-- Incoming Call Banner -->
        <div id="call-notification-banner"
            style="display: none; background: linear-gradient(135deg, #28a745, #20c997); color: white; padding: 1rem; text-align: center; font-weight: 600; animation: slideDown 0.3s ease-out; cursor: pointer;">
            <span id="call-notification-text">üìû Incoming call from User...</span>
            <span style="margin-left: 1rem; text-decoration: underline;">Click to answer</span>
        </div>

        <!-- Active Call Banner (shows when call is in progress) -->
        <div id="active-call-banner"
            style="display: none; background: linear-gradient(135deg, #28a745, #20c997); color: white; padding: 1.5rem; text-align: center; font-weight: 600; cursor: pointer; animation: slideDown 0.3s ease-out; box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4); border-bottom: 3px solid #1e7e34;">
            <div style="font-size: 1.25rem; margin-bottom: 0.5rem;">
                <span id="active-call-text">üî¥ ACTIVE CALL IN PROGRESS</span>
            </div>
            <button id="banner-join-btn"
                style="margin: 0.5rem auto; background: white; color: #28a745; border: none; padding: 0.75rem 2rem; border-radius: 30px; font-weight: 700; cursor: pointer; font-size: 1.125rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: all 0.2s;"
                onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">
                üìû CLICK HERE TO JOIN
            </button>
        </div>

        <div class="chat-header">
            <div>
                <h2 style="margin: 0; font-size: 1.25rem;">{{ other_participant.name }}</h2>
                <p style="margin: 0.25rem 0 0 0; font-size: 0.875rem; opacity: 0.9;">
                    {% if other_participant.current_location and not other_participant.location_privacy %}
                    üìç {{ other_participant.current_location.name }}
                    {% endif %}
                </p>
            </div>
            <div style="display: flex; align-items: center; gap: 1rem;">
                <div class="call-buttons">
                    <button class="call-btn" id="start-call-btn" title="Schedule a Google Meet">
                        üìÖ Schedule Meeting
                    </button>
                </div>
                <div id="connection-status" style="font-size: 0.75rem; font-weight: 500;">üü¢ Connected</div>
            </div>
        </div>

        <div class="chat-messages" id="chat-messages">
            {% for message in messages %}
            <div class="message {% if message.sender == profile %}own{% else %}other{% endif %}"
                data-message-id="{{ message.id }}">
                <div class="message-bubble">
                    {{ message.content|linebreaksbr }}
                </div>
                <div class="message-time">
                    {{ message.timestamp|date:"g:i A" }} ‚Ä¢ {{ message.timestamp|date:"M d" }}
                </div>
            </div>
            {% empty %}
            <div style="text-align: center; color: #999; padding: 2rem;">
                <p>No messages yet. Start the conversation!</p>
            </div>
            {% endfor %}
        </div>

        <div class="chat-input-container">
            <form id="chat-form" class="chat-input-form">
                {% csrf_token %}
                <textarea id="chat-message-input" class="chat-input" placeholder="Type your message..." rows="1"
                    maxlength="2000" required></textarea>
                <button type="submit" class="send-button" id="send-button">Send</button>
            </form>
        </div>
    </div>
</div>

<!-- Incoming Call Modal -->
<div class="call-modal" id="incoming-call-modal">
    <div class="call-modal-content">
        <div class="call-modal-avatar" id="caller-avatar">üë§</div>
        <h2 id="caller-name" style="margin: 0 0 0.5rem 0;">Incoming Call</h2>
        <p id="call-type-text" style="color: #666; margin: 0;">Video Call</p>
        <div class="call-modal-actions">
            <button class="call-accept-btn" id="accept-call-btn">
                ‚úì Accept
            </button>
            <button class="call-reject-btn" id="reject-call-btn">
                ‚úï Reject
            </button>
        </div>
    </div>
</div>

<!-- Active Call Interface -->
<div class="call-interface" id="call-interface">
    <button class="minimize-btn" id="minimize-call-btn" title="Minimize">‚àí</button>
    <button class="maximize-btn" id="maximize-call-btn" title="Maximize">‚ñ°</button>
    <div class="call-video-container">
        <video id="remote-video" class="remote-video" autoplay playsinline></video>
        <video id="local-video" class="local-video" autoplay muted playsinline></video>
        <div class="call-info">
            <div class="call-status" id="call-status-text">Connecting...</div>
            <div class="call-duration" id="call-duration">00:00</div>
        </div>
    </div>
    <div class="call-controls">
        <button class="call-control-btn mute-btn" id="mute-btn" title="Mute/Unmute">
            üé§
        </button>
        <button class="call-control-btn video-btn" id="video-toggle-btn" title="Video On/Off">
            üìπ
        </button>
        <button class="call-control-btn end-call-btn" id="end-call-btn" title="End Call">
            üìû
        </button>
    </div>
</div>

<script>
    // Determine WebSocket protocol (ws or wss)
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = wsProtocol + '//' + window.location.host + '/ws/chat/{{ chat_room.room_name }}/';

    const chatMessages = document.getElementById('chat-messages');
    const chatForm = document.getElementById('chat-form');
    const messageInput = document.getElementById('chat-message-input');
    const sendButton = document.getElementById('send-button');

    // Store current user's profile ID for comparison
    const currentProfileId = parseInt('{{ profile.id }}');
    const roomName = '{{ chat_room.room_name|escapejs }}';
    const sendMessageUrl = '{% url "chat:send_message" chat_room.room_name %}';
    const getMessagesUrl = '{% url "chat:get_messages" chat_room.room_name %}';

    let chatSocket = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    let pendingMessageIds = new Map(); // Track optimistic messages: message content -> temp ID
    let lastMessageTimestamp = null; // Track last message timestamp for polling
    let pollInterval = null; // Interval for polling new messages when WebSocket is down
    const POLL_INTERVAL_MS = 3000; // Poll every 3 seconds when WebSocket is disconnected

    // Connection status indicator
    function updateConnectionStatus(connected) {
        const statusIndicator = document.getElementById('connection-status');
        if (statusIndicator) {
            statusIndicator.textContent = connected ? 'üü¢ Connected' : 'üî¥ Connecting...';
            statusIndicator.style.color = connected ? '#28a745' : '#ffc107';
        }
    }

    // Initialize WebSocket connection
    function connectWebSocket() {
        try {
            console.log('Attempting to connect to WebSocket:', wsUrl);
            chatSocket = new WebSocket(wsUrl);
            updateConnectionStatus(false);

            chatSocket.onopen = function (e) {
                console.log('WebSocket connection opened successfully');
                updateConnectionStatus(true);
                reconnectAttempts = 0;
                // Stop polling when WebSocket is connected
                if (pollInterval) {
                    clearInterval(pollInterval);
                    pollInterval = null;
                }
                // Always keep send button enabled - we use HTTP for sending
                sendButton.disabled = false;
                messageInput.disabled = false;
                messageInput.placeholder = 'Type your message...';
            };

            chatSocket.onmessage = function (e) {
                console.log('WebSocket message received:', e.data);
                const data = JSON.parse(e.data);

                if (data.error) {
                    console.error('Chat error:', data.error);
                    alert('Error: ' + data.error);
                    return;
                }

                // If this is our own message, check if we already showed it optimistically
                const isOwn = parseInt(data.sender_id) === currentProfileId;
                if (isOwn && pendingMessageIds.has(data.message)) {
                    // Find the temporary message we created optimistically
                    const tempId = pendingMessageIds.get(data.message);
                    const existingMessage = chatMessages.querySelector(`[data-temp-id="${tempId}"]`);
                    if (existingMessage) {
                        // Update the existing optimistic message with the real message ID and timestamp
                        existingMessage.removeAttribute('data-temp-id');
                        if (data.message_id) {
                            existingMessage.setAttribute('data-message-id', data.message_id);
                        }
                        // Update timestamp if provided
                        if (data.timestamp) {
                            const timeElement = existingMessage.querySelector('.message-time');
                            if (timeElement) {
                                const timestamp = new Date(data.timestamp);
                                timeElement.textContent = timestamp.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }) +
                                    ' ‚Ä¢ ' + timestamp.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                            }
                            lastMessageTimestamp = data.timestamp;
                        }
                        pendingMessageIds.delete(data.message);
                        return; // Don't create a duplicate
                    }
                }

                // Check if message already exists (by ID) to prevent duplicates
                if (data.message_id) {
                    const existingMsg = chatMessages.querySelector(`[data-message-id="${data.message_id}"]`);
                    if (existingMsg) {
                        return; // Message already displayed
                    }
                }

                // Display the message
                displayMessage(data.message, data.sender_id, data.timestamp, data.message_id, isOwn);
                if (data.timestamp) {
                    lastMessageTimestamp = data.timestamp;
                }
            };

            chatSocket.onerror = function (error) {
                console.error('WebSocket error:', error);
                console.error('WebSocket URL was:', wsUrl);
                console.error('WebSocket readyState:', chatSocket.readyState);
                updateConnectionStatus(false);

                // Show user-friendly error message
                const statusIndicator = document.getElementById('connection-status');
                if (statusIndicator) {
                    statusIndicator.textContent = 'üî¥ Connection Error';
                    statusIndicator.style.color = '#dc3545';
                }
            };

            chatSocket.onclose = function (e) {
                console.log('WebSocket connection closed', 'Code:', e.code, 'Reason:', e.reason, 'WasClean:', e.wasClean);
                updateConnectionStatus(false);
                // Keep send button enabled - we can still send via HTTP
                sendButton.disabled = false;
                messageInput.disabled = false;
                messageInput.placeholder = 'Type your message...';

                // Start polling for new messages when WebSocket is down
                if (!pollInterval) {
                    startPolling();
                }

                // Attempt to reconnect only if it was an unexpected close
                if (!e.wasClean && reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 10000); // Exponential backoff, max 10s
                    console.log(`Reconnecting in ${delay}ms (attempt ${reconnectAttempts}/${maxReconnectAttempts})...`);
                    setTimeout(connectWebSocket, delay);
                } else {
                    if (reconnectAttempts >= maxReconnectAttempts) {
                        console.log('Max reconnection attempts reached. Using HTTP polling for new messages.');
                    }
                }
            };
        } catch (error) {
            console.error('Failed to create WebSocket connection:', error);
            console.error('Error details:', error.message, error.stack);
            // Keep send button enabled - we can still send via HTTP
            sendButton.disabled = false;
            messageInput.disabled = false;
            messageInput.placeholder = 'Type your message...';

            const statusIndicator = document.getElementById('connection-status');
            if (statusIndicator) {
                statusIndicator.textContent = 'üü° HTTP Only';
                statusIndicator.style.color = '#ffc107';
            }

            // Start polling for new messages
            startPolling();
        }
    }

    // Function to poll for new messages when WebSocket is unavailable
    function startPolling() {
        if (pollInterval) {
            return; // Already polling
        }

        console.log('Starting HTTP polling for new messages...');
        pollInterval = setInterval(function () {
            fetchNewMessages();
        }, POLL_INTERVAL_MS);

        // Poll immediately
        fetchNewMessages();
    }

    function stopPolling() {
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
            console.log('Stopped HTTP polling');
        }
    }

    // Function to fetch new messages via HTTP
    function fetchNewMessages() {
        const url = lastMessageTimestamp
            ? `${getMessagesUrl}?since=${encodeURIComponent(lastMessageTimestamp)}`
            : getMessagesUrl;

        fetch(url, {
            method: 'GET',
            headers: {
                'X-Requested-With': 'XMLHttpRequest',
            },
            credentials: 'same-origin'
        })
            .then(response => response.json())
            .then(data => {
                if (data.messages && data.messages.length > 0) {
                    data.messages.forEach(msg => {
                        // Check if message already exists
                        const existingMsg = chatMessages.querySelector(`[data-message-id="${msg.id}"]`);
                        if (!existingMsg) {
                            displayMessage(msg.content, msg.sender_id, msg.timestamp, msg.id, false);
                            lastMessageTimestamp = msg.timestamp;
                        }
                    });
                }
            })
            .catch(error => {
                console.error('Error fetching new messages:', error);
            });
    }

    // Function to display a message in the chat
    function displayMessage(content, senderId, timestamp, messageId, isOwn) {
        // Remove "no messages" placeholder if it exists
        const emptyMessage = chatMessages.querySelector('div[style*="text-align: center"]');
        if (emptyMessage) {
            emptyMessage.remove();
        }

        // Create message element
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${isOwn ? 'own' : 'other'}`;
        if (messageId) {
            messageDiv.setAttribute('data-message-id', messageId);
        }

        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';
        bubble.textContent = content;

        const time = document.createElement('div');
        time.className = 'message-time';
        const msgTimestamp = timestamp ? new Date(timestamp) : new Date();
        time.textContent = msgTimestamp.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }) +
            ' ‚Ä¢ ' + msgTimestamp.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

        messageDiv.appendChild(bubble);
        messageDiv.appendChild(time);

        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // Auto-resize textarea
    messageInput.addEventListener('input', function () {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
    });

    // Scroll to bottom on load
    chatMessages.scrollTop = chatMessages.scrollHeight;

    // Initialize last message timestamp from existing messages
    const existingMessages = chatMessages.querySelectorAll('[data-message-id]');
    if (existingMessages.length > 0) {
        const lastMsg = existingMessages[existingMessages.length - 1];
        const lastMsgTime = lastMsg.querySelector('.message-time');
        if (lastMsgTime) {
            // We'll update this when we get the actual timestamp from the server
        }
    }

    // Initialize connection when page loads (non-blocking)
    connectWebSocket();

    // Also start polling as a fallback (will be stopped if WebSocket connects)
    setTimeout(() => {
        if (!chatSocket || chatSocket.readyState !== WebSocket.OPEN) {
            startPolling();
        }
    }, 1000);

    chatForm.addEventListener('submit', function (e) {
        e.preventDefault();

        const message = messageInput.value.trim();
        if (!message) return;

        // Store message text before clearing input
        const messageText = message;

        // Clear input immediately
        messageInput.value = '';
        messageInput.style.height = 'auto';

        // Generate a unique temporary ID for this optimistic message
        const tempId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        // Show message immediately (optimistic update) with a temporary marker
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message own';
        messageDiv.setAttribute('data-temp-id', tempId);
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';
        bubble.textContent = messageText;
        const time = document.createElement('div');
        time.className = 'message-time';
        const now = new Date();
        time.textContent = now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }) +
            ' ‚Ä¢ ' + now.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        messageDiv.appendChild(bubble);
        messageDiv.appendChild(time);
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        // Track this optimistic message
        pendingMessageIds.set(messageText, tempId);

        // Disable send button temporarily while sending
        sendButton.disabled = true;
        sendButton.textContent = 'Sending...';

        // Send via HTTP POST (always works, regardless of WebSocket connection)
        const formData = new FormData();
        formData.append('message', messageText);
        formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);

        fetch(sendMessageUrl, {
            method: 'POST',
            body: formData,
            headers: {
                'X-Requested-With': 'XMLHttpRequest',
            },
            credentials: 'same-origin'
        })
            .then(response => response.json())
            .then(data => {
                sendButton.disabled = false;
                sendButton.textContent = 'Send';

                if (data.success) {
                    // Update the optimistic message with real data
                    messageDiv.removeAttribute('data-temp-id');
                    if (data.message_id) {
                        messageDiv.setAttribute('data-message-id', data.message_id);
                    }
                    if (data.timestamp) {
                        const timestamp = new Date(data.timestamp);
                        time.textContent = timestamp.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }) +
                            ' ‚Ä¢ ' + timestamp.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    }
                    pendingMessageIds.delete(messageText);
                    lastMessageTimestamp = data.timestamp;

                    pendingMessageIds.delete(messageText);
                    lastMessageTimestamp = data.timestamp;

                    // WebSocket send removed to prevent duplicate messages
                    // The view already broadcasts the message to the group upon saving
                } else {
                    // Error occurred, remove optimistic message
                    alert('Error: ' + (data.error || 'Failed to send message'));
                    messageDiv.remove();
                    pendingMessageIds.delete(messageText);
                }
            })
            .catch(error => {
                console.error('Error sending message:', error);
                console.error('Error sending message:', error);
                sendButton.disabled = false;
                sendButton.textContent = 'Send';
                alert('Failed to send message. Please try again.');
                // Remove the optimistic message if send failed
                messageDiv.remove();
                pendingMessageIds.delete(messageText);
            });
    });

    // ============================================
    // Google Meet Call via Calendar
    // ============================================
    console.log("Call script loaded at: " + new Date().toISOString());

    // UI Elements
    const startCallBtn = document.getElementById('start-call-btn');

    // Start a call - open Google Calendar to create a Meet
    function startCall() {
        console.log("Start call clicked!");

        // Create a Google Calendar event URL with Meet enabled
        const now = new Date();
        const startTime = new Date(now.getTime() + 2 * 60000); // 2 minutes from now
        const endTime = new Date(startTime.getTime() + 60 * 60000); // 1 hour duration

        // Format dates for Google Calendar (YYYYMMDDTHHmmssZ)
        const formatDate = (date) => {
            return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
        };

        const calendarUrl = 'https://calendar.google.com/calendar/render?' +
            'action=TEMPLATE' +
            '&text=' + encodeURIComponent('StudyIt Call with {{ other_participant.name }}') +
            '&dates=' + formatDate(startTime) + '/' + formatDate(endTime) +
            '&details=' + encodeURIComponent('StudyIt video call') +
            '&add=' + encodeURIComponent('{{ other_participant.user.email }}') +
            '&trp=true';  // This adds Google Meet automatically

        // Show simple alert
        alert('Click OK to schedule meeting');

        // Open Google Calendar
        window.open(calendarUrl, '_blank');

        // Send the calendar invite link in the chat
        const messageText = `üìÖ Meeting invite: ${calendarUrl}\n\nClick the link above to join the calendar event and get the Google Meet link!`;

        // Send message via the chat system
        const formData = new FormData();
        formData.append('content', messageText);
        formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);

        fetch('{% url "chat:send_message" chat_room.room_name %}', {
            method: 'POST',
            body: formData,
            credentials: 'same-origin'
        })
            .then(response => response.json())
            .then(data => {
                console.log('Calendar invite sent in chat');
            })
            .catch(error => {
                console.error('Error sending calendar invite in chat:', error);
            });
    }


    // Event listener
    if (startCallBtn) {
        startCallBtn.addEventListener('click', () => {
            console.log("Button clicked!");
            startCall();
        });
        console.log("Event listener attached to start call button");
    } else {
        console.error("Start call button not found!");
    }

</script>
{% endblock %}
```