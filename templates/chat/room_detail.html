{% extends "base.html" %}

{% block title %}Chat with {{ other_participant.name }} - StudyIt{% endblock %}

{% block extra_css %}
<style>
    .chat-container {
        display: flex;
        flex-direction: column;
        height: calc(100vh - 300px);
        max-height: 700px;
        background: white;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        overflow: hidden;
    }

    .chat-header {
        background: #003057;
        color: white;
        padding: 1rem 1.5rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 1.5rem;
        background: #f8f9fa;
    }

    .message {
        margin-bottom: 1rem;
        display: flex;
        flex-direction: column;
    }

    .message.own {
        align-items: flex-end;
    }

    .message.other {
        align-items: flex-start;
    }

    .message-bubble {
        max-width: 70%;
        padding: 0.75rem 1rem;
        border-radius: 18px;
        word-wrap: break-word;
    }

    .message.own .message-bubble {
        background: #003057;
        color: white;
    }

    .message.other .message-bubble {
        background: white;
        color: #333;
        border: 1px solid #ddd;
    }

    .message-time {
        font-size: 0.75rem;
        color: #999;
        margin-top: 0.25rem;
        padding: 0 0.5rem;
    }

    .chat-input-container {
        border-top: 1px solid #ddd;
        padding: 1rem 1.5rem;
        background: white;
    }

    .chat-input-form {
        display: flex;
        gap: 0.75rem;
    }

    .chat-input {
        flex: 1;
        padding: 0.75rem;
        border: 1px solid #ddd;
        border-radius: 20px;
        font-size: 1rem;
        resize: none;
    }

    .chat-input:focus {
        outline: none;
        border-color: #003057;
        box-shadow: 0 0 0 3px rgba(0, 48, 87, 0.1);
    }

    .send-button {
        background: #003057;
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        border-radius: 20px;
        font-weight: 500;
        cursor: pointer;
        white-space: nowrap;
    }

    .send-button:hover {
        background: #004080;
    }

    .send-button:disabled {
        background: #ccc;
        cursor: not-allowed;
    }

    /* Call UI Styles */
    .call-buttons {
        display: flex;
        gap: 0.5rem;
    }

    .call-btn {
        background: white;
        border: 2px solid #003057;
        color: #003057;
        padding: 0.5rem 1rem;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 500;
        font-size: 0.875rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        transition: all 0.2s;
    }

    .call-btn:hover {
        background: #003057;
        color: white;
    }

    .call-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    @keyframes pulse {

        0%,
        100% {
            transform: scale(1);
            box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7);
        }

        50% {
            transform: scale(1.05);
            box-shadow: 0 0 0 10px rgba(40, 167, 69, 0);
        }
    }

    /* Incoming Call Modal */
    .call-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 10000;
        justify-content: center;
        align-items: center;
    }

    .call-modal.active {
        display: flex;
    }

    .call-modal-content {
        background: white;
        padding: 2rem;
        border-radius: 20px;
        text-align: center;
        max-width: 400px;
        animation: slideUp 0.3s ease-out;
    }

    @keyframes slideUp {
        from {
            transform: translateY(50px);
            opacity: 0;
        }

        to {
            transform: translateY(0);
            opacity: 1;
        }
    }

    @keyframes slideDown {
        from {
            transform: translateY(-20px);
            opacity: 0;
        }

        to {
            transform: translateY(0);
            opacity: 1;
        }
    }

    .call-modal-avatar {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        background: #003057;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        margin: 0 auto 1rem;
    }

    .call-modal-actions {
        display: flex;
        gap: 1rem;
        justify-content: center;
        margin-top: 2rem;
    }

    .call-accept-btn,
    .call-reject-btn {
        padding: 1rem 2rem;
        border: none;
        border-radius: 50px;
        font-weight: 600;
        cursor: pointer;
        font-size: 1rem;
        transition: transform 0.2s;
    }

    .call-accept-btn {
        background: #28a745;
        color: white;
    }

    .call-accept-btn:hover {
        background: #218838;
        transform: scale(1.05);
    }

    .call-reject-btn {
        background: #dc3545;
        color: white;
    }

    .call-reject-btn:hover {
        background: #c82333;
        transform: scale(1.05);
    }

    /* Active Call Interface */
    .call-interface {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #1a1a1a;
        z-index: 9999;
        flex-direction: column;
    }

    .call-interface.active {
        display: flex;
    }

    .call-interface.minimized {
        display: block;
        width: 320px;
        height: 240px;
        top: auto;
        bottom: 20px;
        right: 20px;
        left: auto;
        border-radius: 15px;
        overflow: hidden;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        cursor: move;
        transition: none;
    }

    .call-interface.minimized .call-video-container {
        height: calc(100% - 60px);
    }

    .call-interface.minimized .remote-video {
        border-radius: 15px 15px 0 0;
    }

    .call-interface.minimized .local-video {
        width: 80px;
        height: 60px;
        bottom: 65px;
        right: 10px;
    }

    .call-interface.minimized .call-info {
        top: 10px;
        font-size: 0.75rem;
        padding: 0.5rem 1rem;
    }

    .call-interface.minimized .call-controls {
        padding: 0.5rem;
        gap: 0.5rem;
    }

    .call-interface.minimized .call-control-btn {
        width: 40px;
        height: 40px;
        font-size: 1rem;
    }

    .minimize-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 40px;
        height: 40px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.25rem;
        z-index: 10001;
        transition: all 0.2s;
    }

    .minimize-btn:hover {
        background: rgba(0, 0, 0, 0.9);
        transform: scale(1.1);
    }

    .maximize-btn {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 40px;
        height: 40px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.25rem;
        z-index: 10001;
        display: none;
        transition: all 0.2s;
    }

    .call-interface.minimized .maximize-btn {
        display: block;
    }

    .call-interface.minimized .minimize-btn {
        display: none;
    }

    .maximize-btn:hover {
        background: rgba(0, 0, 0, 0.9);
        transform: scale(1.1);
    }

    .call-video-container {
        flex: 1;
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .remote-video {
        width: 100%;
        height: 100%;
        object-fit: contain;
        background: #000;
    }

    .local-video {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 200px;
        height: 150px;
        object-fit: cover;
        border-radius: 10px;
        border: 3px solid white;
        background: #000;
    }

    .call-controls {
        background: rgba(0, 0, 0, 0.9);
        padding: 1.5rem;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 1rem;
    }

    .call-control-btn {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        border: none;
        cursor: pointer;
        font-size: 1.5rem;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .call-control-btn:hover {
        transform: scale(1.1);
    }

    .mute-btn {
        background: #4a5568;
        color: white;
    }

    .mute-btn.muted {
        background: #dc3545;
    }

    .video-btn {
        background: #4a5568;
        color: white;
    }

    .video-btn.disabled {
        background: #dc3545;
    }

    .end-call-btn {
        background: #dc3545;
        color: white;
    }

    .end-call-btn:hover {
        background: #c82333;
    }

    .call-info {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 1rem 2rem;
        border-radius: 10px;
        text-align: center;
    }

    .call-status {
        font-size: 0.875rem;
        opacity: 0.8;
    }

    .call-duration {
        font-size: 1.25rem;
        font-weight: 600;
    }
</style>
{% endblock %}

{% block content %}
<div style="max-width: 1000px; margin: 2rem auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <a href="{% url 'chat:room_list' %}" style="color: #003057; text-decoration: none; font-weight: 500;">‚Üê Back to
            Chats</a>
        <a href="{% url 'accounts:profile_detail' other_participant.user.id %}"
            style="color: #003057; text-decoration: none; font-weight: 500;">
            View Profile
        </a>
    </div>

    <div class="chat-container">
        <!-- Incoming Call Banner -->
        <div id="call-notification-banner"
            style="display: none; background: linear-gradient(135deg, #28a745, #20c997); color: white; padding: 1rem; text-align: center; font-weight: 600; animation: slideDown 0.3s ease-out; cursor: pointer;">
            <span id="call-notification-text">üìû Incoming call from User...</span>
            <span style="margin-left: 1rem; text-decoration: underline;">Click to answer</span>
        </div>

        <!-- Active Call Banner (shows when call is in progress) -->
        <div id="active-call-banner"
            style="display: none; background: linear-gradient(135deg, #28a745, #20c997); color: white; padding: 1.5rem; text-align: center; font-weight: 600; cursor: pointer; animation: slideDown 0.3s ease-out; box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4); border-bottom: 3px solid #1e7e34;">
            <div style="font-size: 1.25rem; margin-bottom: 0.5rem;">
                <span id="active-call-text">üî¥ ACTIVE CALL IN PROGRESS</span>
            </div>
            <button id="banner-join-btn"
                style="margin: 0.5rem auto; background: white; color: #28a745; border: none; padding: 0.75rem 2rem; border-radius: 30px; font-weight: 700; cursor: pointer; font-size: 1.125rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: all 0.2s;"
                onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">
                üìû CLICK HERE TO JOIN
            </button>
        </div>

        <div class="chat-header">
            <div>
                <h2 style="margin: 0; font-size: 1.25rem;">{{ other_participant.name }}</h2>
                <p style="margin: 0.25rem 0 0 0; font-size: 0.875rem; opacity: 0.9;">
                    {% if other_participant.current_location and not other_participant.location_privacy %}
                    üìç {{ other_participant.current_location.name }}
                    {% endif %}
                </p>
            </div>
            <div style="display: flex; align-items: center; gap: 1rem;">
                <div class="call-buttons">
                    <button class="call-btn" id="audio-call-btn" title="Audio Call">
                        üé§ Audio
                    </button>
                    <button class="call-btn" id="video-call-btn" title="Video Call">
                        üìπ Video
                    </button>
                    <button class="call-btn" id="join-call-btn"
                        style="display: none; background: #28a745; color: white; border-color: #28a745; animation: pulse 2s infinite;"
                        title="Join Active Call">
                        üìû Join Call
                    </button>
                </div>
                <div id="connection-status" style="font-size: 0.75rem; font-weight: 500;">üü¢ Connected</div>
            </div>
        </div>

        <div class="chat-messages" id="chat-messages">
            {% for message in messages %}
            <div class="message {% if message.sender == profile %}own{% else %}other{% endif %}"
                data-message-id="{{ message.id }}">
                <div class="message-bubble">
                    {{ message.content|linebreaksbr }}
                </div>
                <div class="message-time">
                    {{ message.timestamp|date:"g:i A" }} ‚Ä¢ {{ message.timestamp|date:"M d" }}
                </div>
            </div>
            {% empty %}
            <div style="text-align: center; color: #999; padding: 2rem;">
                <p>No messages yet. Start the conversation!</p>
            </div>
            {% endfor %}
        </div>

        <div class="chat-input-container">
            <form id="chat-form" class="chat-input-form">
                {% csrf_token %}
                <textarea id="chat-message-input" class="chat-input" placeholder="Type your message..." rows="1"
                    maxlength="2000" required></textarea>
                <button type="submit" class="send-button" id="send-button">Send</button>
            </form>
        </div>
    </div>
</div>

<!-- Incoming Call Modal -->
<div class="call-modal" id="incoming-call-modal">
    <div class="call-modal-content">
        <div class="call-modal-avatar" id="caller-avatar">üë§</div>
        <h2 id="caller-name" style="margin: 0 0 0.5rem 0;">Incoming Call</h2>
        <p id="call-type-text" style="color: #666; margin: 0;">Video Call</p>
        <div class="call-modal-actions">
            <button class="call-accept-btn" id="accept-call-btn">
                ‚úì Accept
            </button>
            <button class="call-reject-btn" id="reject-call-btn">
                ‚úï Reject
            </button>
        </div>
    </div>
</div>

<!-- Active Call Interface -->
<div class="call-interface" id="call-interface">
    <button class="minimize-btn" id="minimize-call-btn" title="Minimize">‚àí</button>
    <button class="maximize-btn" id="maximize-call-btn" title="Maximize">‚ñ°</button>
    <div class="call-video-container">
        <video id="remote-video" class="remote-video" autoplay playsinline></video>
        <video id="local-video" class="local-video" autoplay muted playsinline></video>
        <div class="call-info">
            <div class="call-status" id="call-status-text">Connecting...</div>
            <div class="call-duration" id="call-duration">00:00</div>
        </div>
    </div>
    <div class="call-controls">
        <button class="call-control-btn mute-btn" id="mute-btn" title="Mute/Unmute">
            üé§
        </button>
        <button class="call-control-btn video-btn" id="video-toggle-btn" title="Video On/Off">
            üìπ
        </button>
        <button class="call-control-btn end-call-btn" id="end-call-btn" title="End Call">
            üìû
        </button>
    </div>
</div>

<script>
    // Determine WebSocket protocol (ws or wss)
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = wsProtocol + '//' + window.location.host + '/ws/chat/{{ chat_room.room_name }}/';

    const chatMessages = document.getElementById('chat-messages');
    const chatForm = document.getElementById('chat-form');
    const messageInput = document.getElementById('chat-message-input');
    const sendButton = document.getElementById('send-button');

    // Store current user's profile ID for comparison
    const currentProfileId = parseInt('{{ profile.id }}');
    const roomName = '{{ chat_room.room_name|escapejs }}';
    const sendMessageUrl = '{% url "chat:send_message" chat_room.room_name %}';
    const getMessagesUrl = '{% url "chat:get_messages" chat_room.room_name %}';

    let chatSocket = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    let pendingMessageIds = new Map(); // Track optimistic messages: message content -> temp ID
    let lastMessageTimestamp = null; // Track last message timestamp for polling
    let pollInterval = null; // Interval for polling new messages when WebSocket is down
    const POLL_INTERVAL_MS = 3000; // Poll every 3 seconds when WebSocket is disconnected

    // Connection status indicator
    function updateConnectionStatus(connected) {
        const statusIndicator = document.getElementById('connection-status');
        if (statusIndicator) {
            statusIndicator.textContent = connected ? 'üü¢ Connected' : 'üî¥ Connecting...';
            statusIndicator.style.color = connected ? '#28a745' : '#ffc107';
        }
    }

    // Initialize WebSocket connection
    function connectWebSocket() {
        try {
            console.log('Attempting to connect to WebSocket:', wsUrl);
            chatSocket = new WebSocket(wsUrl);
            updateConnectionStatus(false);

            chatSocket.onopen = function (e) {
                console.log('WebSocket connection opened successfully');
                updateConnectionStatus(true);
                reconnectAttempts = 0;
                // Stop polling when WebSocket is connected
                if (pollInterval) {
                    clearInterval(pollInterval);
                    pollInterval = null;
                }
                // Always keep send button enabled - we use HTTP for sending
                sendButton.disabled = false;
                messageInput.disabled = false;
                messageInput.placeholder = 'Type your message...';
            };

            chatSocket.onmessage = function (e) {
                console.log('WebSocket message received:', e.data);
                const data = JSON.parse(e.data);

                if (data.error) {
                    console.error('Chat error:', data.error);
                    alert('Error: ' + data.error);
                    return;
                }

                // If this is our own message, check if we already showed it optimistically
                const isOwn = parseInt(data.sender_id) === currentProfileId;
                if (isOwn && pendingMessageIds.has(data.message)) {
                    // Find the temporary message we created optimistically
                    const tempId = pendingMessageIds.get(data.message);
                    const existingMessage = chatMessages.querySelector(`[data-temp-id="${tempId}"]`);
                    if (existingMessage) {
                        // Update the existing optimistic message with the real message ID and timestamp
                        existingMessage.removeAttribute('data-temp-id');
                        if (data.message_id) {
                            existingMessage.setAttribute('data-message-id', data.message_id);
                        }
                        // Update timestamp if provided
                        if (data.timestamp) {
                            const timeElement = existingMessage.querySelector('.message-time');
                            if (timeElement) {
                                const timestamp = new Date(data.timestamp);
                                timeElement.textContent = timestamp.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }) +
                                    ' ‚Ä¢ ' + timestamp.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                            }
                            lastMessageTimestamp = data.timestamp;
                        }
                        pendingMessageIds.delete(data.message);
                        return; // Don't create a duplicate
                    }
                }

                // Check if message already exists (by ID) to prevent duplicates
                if (data.message_id) {
                    const existingMsg = chatMessages.querySelector(`[data-message-id="${data.message_id}"]`);
                    if (existingMsg) {
                        return; // Message already displayed
                    }
                }

                // Display the message
                displayMessage(data.message, data.sender_id, data.timestamp, data.message_id, isOwn);
                if (data.timestamp) {
                    lastMessageTimestamp = data.timestamp;
                }
            };

            chatSocket.onerror = function (error) {
                console.error('WebSocket error:', error);
                console.error('WebSocket URL was:', wsUrl);
                console.error('WebSocket readyState:', chatSocket.readyState);
                updateConnectionStatus(false);

                // Show user-friendly error message
                const statusIndicator = document.getElementById('connection-status');
                if (statusIndicator) {
                    statusIndicator.textContent = 'üî¥ Connection Error';
                    statusIndicator.style.color = '#dc3545';
                }
            };

            chatSocket.onclose = function (e) {
                console.log('WebSocket connection closed', 'Code:', e.code, 'Reason:', e.reason, 'WasClean:', e.wasClean);
                updateConnectionStatus(false);
                // Keep send button enabled - we can still send via HTTP
                sendButton.disabled = false;
                messageInput.disabled = false;
                messageInput.placeholder = 'Type your message... (Real-time updates unavailable)';

                // Start polling for new messages when WebSocket is down
                if (!pollInterval) {
                    startPolling();
                }

                // Attempt to reconnect only if it was an unexpected close
                if (!e.wasClean && reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 10000); // Exponential backoff, max 10s
                    console.log(`Reconnecting in ${delay}ms (attempt ${reconnectAttempts}/${maxReconnectAttempts})...`);
                    setTimeout(connectWebSocket, delay);
                } else {
                    if (reconnectAttempts >= maxReconnectAttempts) {
                        console.log('Max reconnection attempts reached. Using HTTP polling for new messages.');
                    }
                }
            };
        } catch (error) {
            console.error('Failed to create WebSocket connection:', error);
            console.error('Error details:', error.message, error.stack);
            // Keep send button enabled - we can still send via HTTP
            sendButton.disabled = false;
            messageInput.disabled = false;
            messageInput.placeholder = 'Type your message... (Real-time updates unavailable)';

            const statusIndicator = document.getElementById('connection-status');
            if (statusIndicator) {
                statusIndicator.textContent = 'üü° HTTP Only';
                statusIndicator.style.color = '#ffc107';
            }

            // Start polling for new messages
            startPolling();
        }
    }

    // Function to poll for new messages when WebSocket is unavailable
    function startPolling() {
        if (pollInterval) {
            return; // Already polling
        }

        console.log('Starting HTTP polling for new messages...');
        pollInterval = setInterval(function () {
            fetchNewMessages();
        }, POLL_INTERVAL_MS);

        // Poll immediately
        fetchNewMessages();
    }

    function stopPolling() {
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
            console.log('Stopped HTTP polling');
        }
    }

    // Function to fetch new messages via HTTP
    function fetchNewMessages() {
        const url = lastMessageTimestamp
            ? `${getMessagesUrl}?since=${encodeURIComponent(lastMessageTimestamp)}`
            : getMessagesUrl;

        fetch(url, {
            method: 'GET',
            headers: {
                'X-Requested-With': 'XMLHttpRequest',
            },
            credentials: 'same-origin'
        })
            .then(response => response.json())
            .then(data => {
                if (data.messages && data.messages.length > 0) {
                    data.messages.forEach(msg => {
                        // Check if message already exists
                        const existingMsg = chatMessages.querySelector(`[data-message-id="${msg.id}"]`);
                        if (!existingMsg) {
                            displayMessage(msg.content, msg.sender_id, msg.timestamp, msg.id, false);
                            lastMessageTimestamp = msg.timestamp;
                        }
                    });
                }
            })
            .catch(error => {
                console.error('Error fetching new messages:', error);
            });
    }

    // Function to display a message in the chat
    function displayMessage(content, senderId, timestamp, messageId, isOwn) {
        // Remove "no messages" placeholder if it exists
        const emptyMessage = chatMessages.querySelector('div[style*="text-align: center"]');
        if (emptyMessage) {
            emptyMessage.remove();
        }

        // Create message element
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${isOwn ? 'own' : 'other'}`;
        if (messageId) {
            messageDiv.setAttribute('data-message-id', messageId);
        }

        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';
        bubble.textContent = content;

        const time = document.createElement('div');
        time.className = 'message-time';
        const msgTimestamp = timestamp ? new Date(timestamp) : new Date();
        time.textContent = msgTimestamp.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }) +
            ' ‚Ä¢ ' + msgTimestamp.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

        messageDiv.appendChild(bubble);
        messageDiv.appendChild(time);

        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // Auto-resize textarea
    messageInput.addEventListener('input', function () {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
    });

    // Scroll to bottom on load
    chatMessages.scrollTop = chatMessages.scrollHeight;

    // Initialize last message timestamp from existing messages
    const existingMessages = chatMessages.querySelectorAll('[data-message-id]');
    if (existingMessages.length > 0) {
        const lastMsg = existingMessages[existingMessages.length - 1];
        const lastMsgTime = lastMsg.querySelector('.message-time');
        if (lastMsgTime) {
            // We'll update this when we get the actual timestamp from the server
        }
    }

    // Initialize connection when page loads (non-blocking)
    connectWebSocket();

    // Also start polling as a fallback (will be stopped if WebSocket connects)
    setTimeout(() => {
        if (!chatSocket || chatSocket.readyState !== WebSocket.OPEN) {
            startPolling();
        }
    }, 1000);

    chatForm.addEventListener('submit', function (e) {
        e.preventDefault();

        const message = messageInput.value.trim();
        if (!message) return;

        // Store message text before clearing input
        const messageText = message;

        // Clear input immediately
        messageInput.value = '';
        messageInput.style.height = 'auto';

        // Generate a unique temporary ID for this optimistic message
        const tempId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        // Show message immediately (optimistic update) with a temporary marker
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message own';
        messageDiv.setAttribute('data-temp-id', tempId);
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';
        bubble.textContent = messageText;
        const time = document.createElement('div');
        time.className = 'message-time';
        const now = new Date();
        time.textContent = now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }) +
            ' ‚Ä¢ ' + now.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        messageDiv.appendChild(bubble);
        messageDiv.appendChild(time);
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        // Track this optimistic message
        pendingMessageIds.set(messageText, tempId);

        // Disable send button temporarily while sending
        sendButton.disabled = true;
        sendButton.textContent = 'Sending...';

        // Send via HTTP POST (always works, regardless of WebSocket connection)
        const formData = new FormData();
        formData.append('message', messageText);
        formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);

        fetch(sendMessageUrl, {
            method: 'POST',
            body: formData,
            headers: {
                'X-Requested-With': 'XMLHttpRequest',
            },
            credentials: 'same-origin'
        })
            .then(response => response.json())
            .then(data => {
                sendButton.disabled = false;
                sendButton.textContent = 'Send';

                if (data.success) {
                    // Update the optimistic message with real data
                    messageDiv.removeAttribute('data-temp-id');
                    if (data.message_id) {
                        messageDiv.setAttribute('data-message-id', data.message_id);
                    }
                    if (data.timestamp) {
                        const timestamp = new Date(data.timestamp);
                        time.textContent = timestamp.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }) +
                            ' ‚Ä¢ ' + timestamp.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    }
                    pendingMessageIds.delete(messageText);
                    lastMessageTimestamp = data.timestamp;

                    pendingMessageIds.delete(messageText);
                    lastMessageTimestamp = data.timestamp;

                    // WebSocket send removed to prevent duplicate messages
                    // The view already broadcasts the message to the group upon saving
                } else {
                    // Error occurred, remove optimistic message
                    alert('Error: ' + (data.error || 'Failed to send message'));
                    messageDiv.remove();
                    pendingMessageIds.delete(messageText);
                }
            })
            .catch(error => {
                console.error('Error sending message:', error);
                sendButton.disabled = false;
                sendButton.textContent = 'Send';
                alert('Failed to send message. Please try again.');
                // Remove the optimistic message if send failed
                messageDiv.remove();
                pendingMessageIds.delete(messageText);
            });
    });

    // ============================================
    // WebRTC Voice/Video Call Implementation
    // ============================================

    // Call state variables
    let callSignalingSocket = null;
    let peerConnection = null;
    let localStream = null;
    let remoteStream = null;
    let currentCallId = null;
    let currentCallType = null;
    let callStartTime = null;
    let callDurationInterval = null;
    let isCallInitiator = false;

    // WebRTC configuration (using Google's public STUN servers)
    const rtcConfiguration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
        ]
    };

    // UI Elements
    const audioCallBtn = document.getElementById('audio-call-btn');
    const videoCallBtn = document.getElementById('video-call-btn');
    const joinCallBtn = document.getElementById('join-call-btn');
    const incomingCallModal = document.getElementById('incoming-call-modal');
    const acceptCallBtn = document.getElementById('accept-call-btn');
    const rejectCallBtn = document.getElementById('reject-call-btn');
    const callInterface = document.getElementById('call-interface');
    const localVideo = document.getElementById('local-video');
    const remoteVideo = document.getElementById('remote-video');
    const muteBtn = document.getElementById('mute-btn');
    const videoToggleBtn = document.getElementById('video-toggle-btn');
    const endCallBtn = document.getElementById('end-call-btn');
    const minimizeCallBtn = document.getElementById('minimize-call-btn');
    const maximizeCallBtn = document.getElementById('maximize-call-btn');
    const callStatusText = document.getElementById('call-status-text');
    const callDurationDisplay = document.getElementById('call-duration');
    const callNotificationBanner = document.getElementById('call-notification-banner');
    const callNotificationText = document.getElementById('call-notification-text');
    const activeCallBanner = document.getElementById('active-call-banner');
    const activeCallText = document.getElementById('active-call-text');
    const bannerJoinBtn = document.getElementById('banner-join-btn');

    // Store pending incoming call data
    let pendingIncomingCall = null;
    let activeCallInRoom = false;

    // Initialize call signaling WebSocket
    function initCallSignaling() {
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = wsProtocol + '//' + window.location.host + '/ws/call/{{ chat_room.room_name }}/';

        callSignalingSocket = new WebSocket(wsUrl);

        callSignalingSocket.onopen = () => {
            console.log('Call signaling connected');
        };

        callSignalingSocket.onmessage = async (event) => {
            const data = JSON.parse(event.data);
            console.log('Call signaling message:', data);

            switch (data.type) {
                case 'connection_established':
                    console.log('Call signaling ready');
                    break;

                case 'call_offer':
                    // Receiving incoming call
                    if (data.caller_id !== currentProfileId) {
                        handleIncomingCall(data);
                    }
                    break;

                case 'call_answer':
                    // Caller receives answer from receiver
                    if (data.answerer_id !== currentProfileId) {
                        await handleCallAnswer(data.answer);
                    }
                    break;

                case 'ice_candidate':
                    // Receive ICE candidate
                    if (data.candidate && peerConnection) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                    }
                    break;

                case 'call_rejected':
                    handleCallRejected(data);
                    break;

                case 'call_ended':
                    handleCallEnded(data);
                    break;

                case 'call_cancelled':
                    handleCallCancelled(data);
                    break;

                case 'call_join_request':
                    // Someone wants to join the active call
                    console.log(data.joiner_name + ' wants to join the call');

                    // If we're the one in the call (have active peerConnection), re-send our offer
                    if (peerConnection && isCallInitiator) {
                        console.log('Re-sending offer to joiner...');

                        // Create a new offer for the joiner
                        peerConnection.createOffer()
                            .then(offer => peerConnection.setLocalDescription(offer))
                            .then(() => {
                                // Send the offer via signaling
                                callSignalingSocket.send(JSON.stringify({
                                    type: 'call_offer',
                                    offer: peerConnection.localDescription,
                                    call_type: currentCallType
                                }));
                            })
                            .catch(error => {
                                console.error('Error creating offer for joiner:', error);
                            });
                    }
                    break;

                case 'user_disconnected':
                    if (peerConnection) {
                        alert('Other user disconnected');
                        endCall();
                    }
                    break;

                case 'error':
                    console.error('Call signaling error:', data.message);
                    break;
            }
        };

        callSignalingSocket.onerror = (error) => {
            console.error('Call signaling error:', error);
        };

        callSignalingSocket.onclose = () => {
            console.log('Call signaling disconnected');
            // Try to reconnect after a delay
            setTimeout(initCallSignaling, 3000);
        };
    }

    // Check for active calls on page load
    async function checkForActiveCalls() {
        try {
            const response = await fetch('{% url "chat:initiate_call" chat_room.room_name %}', {
                method: 'GET',
                credentials: 'same-origin'
            });

            // If there's an active call, we'll get info about it
            if (response.ok) {
                const data = await response.json();
                if (data.active_call) {
                    showActiveCallBanner(data.active_call);
                }
            }
        } catch (error) {
            console.log('No active call check endpoint, skipping...');
        }
    }

    // Show active call banner
    function showActiveCallBanner(callInfo) {
        activeCallInRoom = true;

        if (!peerConnection) {  // Only show if we're not already in the call
            activeCallText.textContent = `üî¥ ${callInfo.call_type} call in progress`;
            activeCallBanner.style.display = 'block';

            // Also show join button
            joinCallBtn.style.display = 'flex';
            joinCallBtn.textContent = `üìû Join ${callInfo.call_type === 'video' ? 'Video' : 'Audio'} Call`;

            // Hide start call buttons
            audioCallBtn.style.display = 'none';
            videoCallBtn.style.display = 'none';
        }
    }

    // Hide active call banner
    function hideActiveCallBanner() {
        activeCallInRoom = false;
        activeCallBanner.style.display = 'none';

        if (!pendingIncomingCall) {
            // Restore start call buttons if no pending incoming call
            audioCallBtn.style.display = 'flex';
            videoCallBtn.style.display = 'flex';
            joinCallBtn.style.display = 'none';
        }
    }

    // Initialize signaling when page loads
    initCallSignaling();

    // Check for active calls on load
    checkForActiveCalls();

    // Auto-join if coming from Calls page
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('auto_join') === 'true') {
        console.log('Auto-join triggered from Calls page');

        // Wait longer for WebSocket to connect and call state to be established
        setTimeout(() => {
            console.log('Auto-join check - activeCallInRoom:', activeCallInRoom, 'pendingIncomingCall:', !!pendingIncomingCall);

            // If there's a pending incoming call, accept it
            if (pendingIncomingCall) {
                console.log('Auto-joining pending call');
                acceptIncomingCall();
            }
            // If there's an active call in room, show join button and trigger join
            else if (activeCallInRoom) {
                console.log('Active call detected, ensuring join button is visible');

                // Make sure join button is visible
                joinCallBtn.style.display = 'flex';
                joinCallBtn.textContent = `üìû Join ${currentCallType || 'Audio'} Call`;

                // Hide start call buttons
                audioCallBtn.style.display = 'none';
                videoCallBtn.style.display = 'none';

                // Trigger join
                console.log('Auto-joining active call');
                joinActiveCall();
            }
            // Otherwise show message
            else {
                console.log('No active call found');
                alert('Call may have ended. Please start a new call.');
            }
        }, 2000); // Wait 2 seconds for everything to load
    }

    // Start a call
    async function startCall(callType) {
        try {
            currentCallType = callType;
            isCallInitiator = true;

            // Disable call buttons
            audioCallBtn.disabled = true;
            videoCallBtn.disabled = true;

            // Create call in database
            const formData = new FormData();
            formData.append('call_type', callType);
            formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);

            const response = await fetch('{% url "chat:initiate_call" chat_room.room_name %}', {
                method: 'POST',
                body: formData,
                credentials: 'same-origin'
            });

            const data = await response.json();

            if (!data.success) {
                alert(data.error || 'Failed to initiate call');
                audioCallBtn.disabled = false;
                videoCallBtn.disabled = false;
                return;
            }

            currentCallId = data.call_id;
            activeCallInRoom = true;

            // Show active call banner for other user to see
            activeCallText.textContent = `üî¥ ${callType} call in progress`;
            activeCallBanner.style.display = 'block';

            // Get user media
            const constraints = {
                audio: true,
                video: callType === 'video'
            };

            localStream = await navigator.mediaDevices.getUserMedia(constraints);

            // Show call interface
            callInterface.classList.add('active');
            localVideo.srcObject = localStream;
            callStatusText.textContent = 'Calling...';

            // Hide video element if audio-only
            if (callType === 'audio') {
                localVideo.style.display = 'none';
                remoteVideo.style.display = 'none';
            }

            // Create peer connection
            await createPeerConnection();

            // Add local stream tracks
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // Create and send offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            // Send offer via signaling
            callSignalingSocket.send(JSON.stringify({
                type: 'call_offer',
                offer: offer,
                call_type: callType
            }));

        } catch (error) {
            console.error('Error starting call:', error);
            alert('Failed to start call: ' + error.message);
            endCall();
        }
    }

    // Handle incoming call
    function handleIncomingCall(data) {
        console.log('handleIncomingCall called with data:', data);

        currentCallType = data.call_type;
        isCallInitiator = false;
        activeCallInRoom = true;

        // Store incoming call data persistently
        pendingIncomingCall = {
            offer: data.offer,
            caller_name: data.caller_name,
            caller_id: data.caller_id,
            call_type: data.call_type
        };

        console.log('Stored pendingIncomingCall:', pendingIncomingCall);

        // Show incoming call modal
        document.getElementById('caller-name').textContent = data.caller_name;
        document.getElementById('call-type-text').textContent =
            data.call_type === 'video' ? 'Video Call' : 'Audio Call';
        incomingCallModal.classList.add('active');

        // Show notification banner at top
        callNotificationText.textContent = `üìû Incoming call from ${data.caller_name}...`;
        callNotificationBanner.style.display = 'block';

        // Also show active call banner (for persistent join option)
        activeCallText.textContent = `üî¥ ${data.call_type} call from ${data.caller_name}`;
        activeCallBanner.style.display = 'block';

        // ALSO show the Join Call button (in case they close the modal)
        joinCallBtn.style.display = 'flex';
        joinCallBtn.textContent = `üìû Join ${data.call_type === 'video' ? 'Video' : 'Audio'} Call`;

        console.log('Join button should now be visible');

        // Hide the start call buttons while there's a pending call
        audioCallBtn.style.display = 'none';
        videoCallBtn.style.display = 'none';

        // Play ringtone (optional - you'd need to add an audio element)
        // document.getElementById('ringtone').play();
    }

    // Accept incoming call
    async function acceptIncomingCall() {
        try {
            // Check if we have pending call data
            if (!pendingIncomingCall) {
                alert('No incoming call to accept');
                return;
            }

            // Close modal and hide incoming call UI
            incomingCallModal.classList.remove('active');
            joinCallBtn.style.display = 'none';
            callNotificationBanner.style.display = 'none';

            // Update active call banner to show we're now in the call
            activeCallText.textContent = `üî¥ In ${currentCallType} call`;
            activeCallBanner.style.display = 'block';

            // Get user media
            const constraints = {
                audio: true,
                video: currentCallType === 'video'
            };

            localStream = await navigator.mediaDevices.getUserMedia(constraints);

            // Show call interface
            callInterface.classList.add('active');
            localVideo.srcObject = localStream;
            callStatusText.textContent = 'Connecting...';

            // Hide video if audio-only
            if (currentCallType === 'audio') {
                localVideo.style.display = 'none';
                remoteVideo.style.display = 'none';
            }

            // Create peer connection
            await createPeerConnection();

            // Add local stream tracks
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // Set remote description (offer) from stored data
            await peerConnection.setRemoteDescription(new RTCSessionDescription(pendingIncomingCall.offer));

            // Create answer
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            // Send answer via signaling
            callSignalingSocket.send(JSON.stringify({
                type: 'call_answer',
                answer: answer
            }));

            // Clear pending call data
            pendingIncomingCall = null;

            startCallDuration();

        } catch (error) {
            console.error('Error accepting call:', error);
            alert('Failed to accept call: ' + error.message);
            endCall();
        }
    }

    // Handle call answer (for caller)
    async function handleCallAnswer(answer) {
        try {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
            callStatusText.textContent = 'Connected';

            // Update active call banner
            activeCallText.textContent = `üî¥ In ${currentCallType} call`;

            startCallDuration();

            // Show notification that they can minimize
            setTimeout(() => {
                if (callInterface.classList.contains('active') && !callInterface.classList.contains('minimized')) {
                    callStatusText.textContent = 'Connected - You can minimize to navigate';
                }
            }, 3000);
        } catch (error) {
            console.error('Error handling answer:', error);
        }
    }

    // Reject incoming call
    function rejectIncomingCall() {
        incomingCallModal.classList.remove('active');

        // Hide incoming call UI, but keep active call banner visible
        // (in case they change their mind and want to join)
        callNotificationBanner.style.display = 'none';

        // Keep the active call banner and join button visible
        // So they can still join if they change their mind
        activeCallText.textContent = `üî¥ Call in progress - Click to join`;

        // Send rejection via signaling
        callSignalingSocket.send(JSON.stringify({
            type: 'call_reject'
        }));

        // KEEP pendingIncomingCall so they can join later!
        // Just mark it as declined
        if (pendingIncomingCall) {
            pendingIncomingCall.declined = true;
        }
    }

    // Handle call rejection (for caller)
    function handleCallRejected(data) {
        alert(data.rejector_name + ' declined the call. They can still join if they change their mind.');

        // Don't end call immediately - keep it active so they can join later
        // Just update the status
        callStatusText.textContent = 'Waiting for other person to join...';

        // They can still end the call manually if they want
    }

    // Handle call ended
    function handleCallEnded(data) {
        // Hide all call banners
        activeCallBanner.style.display = 'none';
        callNotificationBanner.style.display = 'none';

        alert('Call ended by ' + data.ender_name);
        endCall();
    }

    // Handle call cancelled
    function handleCallCancelled(data) {
        incomingCallModal.classList.remove('active');

        // Hide all call UI and show call buttons again
        joinCallBtn.style.display = 'none';
        callNotificationBanner.style.display = 'none';
        activeCallBanner.style.display = 'none';
        audioCallBtn.style.display = 'flex';
        videoCallBtn.style.display = 'flex';

        alert(data.canceller_name + ' cancelled the call');
        currentCallType = null;
        pendingIncomingCall = null;
        activeCallInRoom = false;
    }

    // Create peer connection
    async function createPeerConnection() {
        peerConnection = new RTCPeerConnection(rtcConfiguration);

        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                callSignalingSocket.send(JSON.stringify({
                    type: 'ice_candidate',
                    candidate: event.candidate
                }));
            }
        };

        // Handle remote stream
        peerConnection.ontrack = (event) => {
            if (event.streams && event.streams[0]) {
                remoteStream = event.streams[0];
                remoteVideo.srcObject = remoteStream;
                callStatusText.textContent = 'Connected';
            }
        };

        // Handle connection state changes
        peerConnection.onconnectionstatechange = () => {
            console.log('Connection state:', peerConnection.connectionState);

            if (peerConnection.connectionState === 'connected') {
                callStatusText.textContent = 'Connected';

                // Show notification that they can minimize after 3 seconds
                setTimeout(() => {
                    if (callInterface.classList.contains('active') && !callInterface.classList.contains('minimized')) {
                        callStatusText.textContent = 'Connected - Click ‚àí to minimize';
                    }
                }, 3000);
            } else if (peerConnection.connectionState === 'disconnected' ||
                peerConnection.connectionState === 'failed') {
                endCall();
            }
        };

        return peerConnection;
    }

    // Toggle mute
    function toggleMute() {
        if (localStream) {
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                muteBtn.classList.toggle('muted', !audioTrack.enabled);
                muteBtn.textContent = audioTrack.enabled ? 'üé§' : 'üîá';
            }
        }
    }

    // Toggle video
    function toggleVideo() {
        if (localStream && currentCallType === 'video') {
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                videoToggleBtn.classList.toggle('disabled', !videoTrack.enabled);
                videoToggleBtn.textContent = videoTrack.enabled ? 'üìπ' : 'üì∑';
            }
        }
    }

    // Minimize call window
    function minimizeCall() {
        callInterface.classList.add('minimized');
        console.log('Call minimized - you can navigate away and return');
    }

    // Maximize call window
    function maximizeCall() {
        callInterface.classList.remove('minimized');
        console.log('Call maximized');
    }

    // Make minimized call window draggable
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;

    callInterface.addEventListener('mousedown', (e) => {
        if (callInterface.classList.contains('minimized') && e.target === callInterface) {
            initialX = e.clientX - xOffset;
            initialY = e.clientY - yOffset;
            isDragging = true;
        }
    });

    document.addEventListener('mousemove', (e) => {
        if (isDragging) {
            e.preventDefault();
            currentX = e.clientX - initialX;
            currentY = e.clientY - initialY;
            xOffset = currentX;
            yOffset = currentY;

            callInterface.style.transform = `translate(${currentX}px, ${currentY}px)`;
        }
    });

    document.addEventListener('mouseup', () => {
        isDragging = false;
    });

    // Start call duration counter
    function startCallDuration() {
        callStartTime = Date.now();
        callDurationInterval = setInterval(() => {
            const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            callDurationDisplay.textContent =
                String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0');
        }, 1000);
    }

    // End call
    async function endCall() {
        // Send end signal
        if (callSignalingSocket && callSignalingSocket.readyState === WebSocket.OPEN) {
            callSignalingSocket.send(JSON.stringify({
                type: 'call_end'
            }));
        }

        // Stop local stream
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }

        // Close peer connection
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }

        // Clear remote stream
        if (remoteVideo.srcObject) {
            remoteVideo.srcObject = null;
        }
        if (localVideo.srcObject) {
            localVideo.srcObject = null;
        }

        // Stop duration counter
        if (callDurationInterval) {
            clearInterval(callDurationInterval);
            callDurationInterval = null;
        }

        // Update call in database
        if (currentCallId) {
            const formData = new FormData();
            formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);

            await fetch(`/chat/calls/${currentCallId}/end/`, {
                method: 'POST',
                body: formData,
                credentials: 'same-origin'
            });
        }

        // Hide call interface
        callInterface.classList.remove('active');

        // Reset state
        currentCallId = null;
        currentCallType = null;
        isCallInitiator = false;
        callStartTime = null;
        remoteStream = null;

        // Reset UI
        callStatusText.textContent = 'Connecting...';
        callDurationDisplay.textContent = '00:00';
        muteBtn.classList.remove('muted');
        muteBtn.textContent = 'üé§';
        videoToggleBtn.classList.remove('disabled');
        videoToggleBtn.textContent = 'üìπ';
        localVideo.style.display = '';
        remoteVideo.style.display = '';

        // Re-enable and show call buttons, hide join button and banners
        audioCallBtn.disabled = false;
        videoCallBtn.disabled = false;
        audioCallBtn.style.display = 'flex';
        videoCallBtn.style.display = 'flex';
        joinCallBtn.style.display = 'none';
        callNotificationBanner.style.display = 'none';
        activeCallBanner.style.display = 'none';

        // Clear pending call and active call state
        pendingIncomingCall = null;
        activeCallInRoom = false;
    }

    // Join active call after declining/missing
    async function joinActiveCall() {
        if (!activeCallInRoom) {
            alert('No active call to join');
            return;
        }

        // If we have pending incoming call data, just accept it
        if (pendingIncomingCall) {
            await acceptIncomingCall();
            return;
        }

        // Otherwise, request to join the active call
        console.log('Requesting to join active call...');

        // Hide the join button and banners while we're setting up
        joinCallBtn.style.display = 'none';
        activeCallBanner.style.display = 'none';

        // Mark that we're not the initiator
        isCallInitiator = false;

        // Send join request via signaling
        if (callSignalingSocket && callSignalingSocket.readyState === WebSocket.OPEN) {
            callSignalingSocket.send(JSON.stringify({
                type: 'request_to_join'
            }));

            console.log('Join request sent. Waiting for offer from other user...');
            // The offer will come through the normal 'call_offer' handler
            // and will trigger handleIncomingCall, which we'll then accept automatically
        } else {
            alert('Connection error. Please refresh and try again.');
            joinCallBtn.style.display = 'flex';
            activeCallBanner.style.display = 'block';
        }
    }

    // Event listeners
    audioCallBtn.addEventListener('click', () => startCall('audio'));
    videoCallBtn.addEventListener('click', () => startCall('video'));
    joinCallBtn.addEventListener('click', joinActiveCall);  // Join button for active calls
    acceptCallBtn.addEventListener('click', acceptIncomingCall);
    rejectCallBtn.addEventListener('click', rejectIncomingCall);
    callNotificationBanner.addEventListener('click', acceptIncomingCall);  // Clicking incoming banner answers call
    activeCallBanner.addEventListener('click', joinActiveCall);  // Clicking active call banner joins
    if (bannerJoinBtn) {
        bannerJoinBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent banner click from also firing
            joinActiveCall();
        });
    }
    muteBtn.addEventListener('click', toggleMute);
    videoToggleBtn.addEventListener('click', toggleVideo);
    endCallBtn.addEventListener('click', endCall);
    minimizeCallBtn.addEventListener('click', minimizeCall);
    maximizeCallBtn.addEventListener('click', maximizeCall);

    // Handle page unload - warn but don't auto-end call
    window.addEventListener('beforeunload', (e) => {
        if (peerConnection && callInterface.classList.contains('active')) {
            // Only warn if call is active and NOT minimized
            if (!callInterface.classList.contains('minimized')) {
                e.preventDefault();
                e.returnValue = 'You are currently in a call. Minimize the call to navigate away, or hang up to end it.';
                return e.returnValue;
            }
            // If minimized, allow navigation and the call will continue
        }
    });

</script>
{% endblock %}